---
title: "Untitled"
author: "Doug Barrows"
date: "April 28, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 
```{r}
library(ShortRead)


fastQ <- readFastq("./bladder_control_ENCFF188POD.fastq")
dupLogical <- srduplicated(fastQ)
numberOfDups <- table(dupLogical)
nonDups <- fastQ[dupLogical]

myQA <- qa("./bladder_control_ENCFF188POD.fastq")
myReport <- report(myQA)
browseURL(myReport)

```

```{r}
fastq_path <- ""

fastQ_to_bigwig <- function(fastq_path, mapq) {

  
library(Rsubread)
library(Rsamtools)
library(BSgenome.Hsapiens.UCSC.hg38)
library(BSgenome.Hsapiens.UCSC.hg19)
library(rtracklayer)
library(GenomicAlignments)
library(ggplot2)

  
if (missing(mapq)) {
  mapq <- 15
}
  
fastq <- list.files(fastq_path)
########
# inputs
#########

fastq <- "bladder_control_ENCFF188POD.fastq"
mapq <- 15

###########

# Now we loop through file, filter reads and write out a FastQ of our filtered reads

fqStreamer <- FastqStreamer("./bladder_control_ENCFF188POD.fastq",
                            n=5000000)
filtered_fastq <- paste0( "filtered_",fastq)

TotalReads <- 0
TotalReadsFilt <- 0
while (length(fq <- yield(fqStreamer))>0) {
    TotalReads <- TotalReads+length(fq)
    filt1 <- fq[alphabetScore(fq) > 300 ]
    filt2 <- filt1[alphabetFrequency(sread(filt1))[,"N"] < 10]
    TotalReadsFilt <- TotalReadsFilt+length(filt2)
    writeFastq(filt2, filtered_fastq ,mode="a")
}
TotalReads
TotalReadsFilt


########## build the index for Rsubread alignment - only need to do this once

# Here we cycle through the major chromosomes and create a DNAStringSet object from the retrieved sequences.
if (buildIndex = TRUE) {
  
  mainChromosomes <- paste0("chr", c(1:19, "X", "Y", "M"))
  mainChrSeq <- lapply(mainChromosomes,
  function(x)
  BSgenome.Hsapiens.UCSC.hg19[[x]])
  names(mainChrSeq) <- mainChromosomes
  mainChrSeqSet <- DNAStringSet(mainChrSeq)
  
  # Now we have a DNAStringSet object we can use the writeXStringSet to create our FASTA file of sequences to align to.
  
  writeXStringSet(mainChrSeqSet,
  "BSgenome.Hsapiens.UCSC.hg19.fa")
  
  #The Rsubread package offers a faster aligner than the QuasR package although the Rsubread package. For alignment with the Rsubread package we must first build our genome index for Rsubread using the buildindex() function.The buildindex() function simply takes the parameters of our desired index name and the FASTA file to build index from.
  
  buildindex("BSgenome.Hsapiens.UCSC.hg19",
  "BSgenome.Hsapiens.UCSC.hg19.fa")
  
}
###### now to the alignment

# exreact the base part of the name of each fast1 file so that this can be ussed as the base for output files generated below
if (grepl(".fastq", filtered_fastq)) {
  base <- strsplit(filtered_fastq, ".fastq", fixed = TRUE)[[1]][1]
} else if (grepl(".fq", filtered_fastq)){
  base <- strsplit(filtered_fastq, ".fq", fixed = TRUE)[[1]][1]
}

#align with Rsubread
bam <- paste0(base, ".BAM")

# here I am using the filtered fastq, do we need to do this given that we filter out low quality alignments? I suppose we don't, but it might make the alignments faster if we are gettign rid of bad reads befroehand

align(index = "BSgenome.Hsapiens.UCSC.hg19",
      readfile1 = filtered_fastq,
      output_file=bam,
      type="dna",phredOffset = 64)

sorted_bam_pre <- paste0(base, "_sorted")
sortBam(bam, sorted_bam_pre) # don't put ".BAM" at end of output file as it adds it anyway

sorted_bam_post <- paste0(base, "_sorted.BAM")
indexBam(sorted_bam_post)

print("BamFlagSummary without filtering:")
print(quickBamFlagSummary(sorted_bam_post))

# filter out low quality reads
param <- ScanBamParam(mapqFilter = mapq, 
                       flag = scanBamFlag(isDuplicate = FALSE))
sorted_bam_mpost_mapq <- paste0(sorted_bam_pre, "nodup_q", as.character(mapq), ".BAM")
filterBam(file = sorted_bam_post, destination = sorted_bam_mpost_mapq, param = param)

print("BamFlagSummary post filtering:")
print(quickBamFlagSummary(sorted_bam_mpost_mapq))

# make figure showing all mapped reads to each chromosome
mappedReads <- idxstatsBam(sorted_bam_mpost_mapq)
TotalMapped <- sum(mappedReads[,"mapped"])
ggplot(mappedReads,aes(x=seqnames,y=mapped))+
  geom_bar(stat="identity")
  
# make big wig
alignment <- readGAlignments(sorted_bam_mpost_mapq)
reads_coverage <- coverage(alignment)

export.bw(reads_coverage, con = paste0(base, "_BigWig.bw"))

}
```

### ChIP QC

```{r}
library(ChIPQC)

# using the pre-filtered BAM
QCresult <- ChIPQCsample(reads="./filtered_bladder_control_ENCFF188POD_sorted_q15_nodup15.BAM",
                         annotation="hg19",
                         blacklist = "./wgEncodeHg19ConsensusSignalArtifactRegions.bed")
QCmetrics(QCresult)

myFlags <- flagtagcounts(QCresult)
myFlags["DuplicateByChIPQC"]/myFlags["Mapped"]

plotCC(QCresult)
plotSSD(QCresult)+xlim(0,5)

# use lapply to run on multiple BAMS
#bamsToQC <- c("Sorted_Myc_Ch12_1.bam","Sorted_Myc_Ch12_2.bam",
#             "Sorted_Myc_MEL_1.bam","Sorted_Myc_MEL_2.bam",
#             "Sorted_Input_MEL.bam","Sorted_Input_Ch12.bam")
#myQC <- bplapply(bamsToQC,ChIPQCsample,
#        annotation = "mm10",
#        blacklist = toBlkList,
#        chromosomes = paste0("chr",1:10))
#names(myQC) <- bamsToQC
#QCmetrics(myQC)
#plotCC(myQC,facetBy = "Sample")
#plotSSD(myQC)+xlim(0,5)

# We can include metadata as a data.frame where the first column is our sample names.
#myMeta <- data.frame(Sample= names(myQC),
#                     Tissue=c("Ch12","Ch12","MEL","MEL","MEL","Ch12"),
#                     Antibody=c(rep("Myc",4),rep("Input",2)))
#myMeta


```



###peak calling

```{r}
input <- c("input1","input2", "input3")
bam <- c("bam1","bam2", "bam3")
broad <- c(0,1,0)
base <- c("base1", "base2", "base3")

data <- data.frame(Base = base, BAM = bam, Input = input, Broad = broad)

macs2_loop <- function (data,  bw, q, genome){
  
  if (missing(bw)) {
    bw <- 150
  }
  if (missing(q)) {
    q <- 0.05
  }
    if (missing(genome)) {
    genome <- "hs"
  }

   for (i in 1:nrow(data)) {
     if (data[i,4] == 0) {
      dir.create(paste0("./", data[i,1], "_peaks/"))
      path_output <- paste0("./", data[i,1], "_peaks/")
      
      print(paste0("macs2 callpeak", 
                   "-t ", data[i, 2], 
                   " -c ", data[i, 3], 
                   " -g ", genome,
                   " --outdir ", path_output, 
                   " -n ",  data[i,1], 
                   " --bw ", bw, " -q ", q))  
     }
     else {
       dir.create(paste0("./", data[i,1], "_broad_peaks/"))
      path_output <- paste0("./", data[i,1], "_broad_peaks/")
      
      print(paste0("macs2 callpeak", 
                   " -t ", data[i, 2], 
                   " -c ", data[i, 3], 
                   " -g ", genome, 
                   " --outdir ", path_output, 
                   " -n ",  data[i,1], 
                   " --broad", 
                   " --bw", bw, " -q ", q))  
     }
   }
}
  


macs2_loop(data = data)

#### must open r studio fro terminal with command "open -a RStudio" for the system command to inheret the right path
dir.create("./PeakDirectory")
ChIP <- "filtered_K27Ac_bladder_ENCFF413QKU_sorted_q_rmdup15.BAM"
control <- "filtered_bladder_control_ENCFF188POD_sorted_q15_nodup15.BAM"

macsCommand <- paste0("macs2 callpeak -t ", ChIP,
                      " -c ", control,
                      " -n ", "K27ac_encodebladder",
                      " --outdir PeakDirectory")
system(macsCommand)
```


